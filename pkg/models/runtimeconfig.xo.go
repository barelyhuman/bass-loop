package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// RuntimeConfig represents a row from 'runtime_configs'.
type RuntimeConfig struct {
	UserID   string `json:"user_id"`   // user_id
	Platform string `json:"platform"`  // platform
	Runtime  string `json:"runtime"`   // runtime
	Config   string `json:"config"`    // config
	LastSeen Time   `json:"last_seen"` // last_seen
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the RuntimeConfig exists in the database.
func (rc *RuntimeConfig) Exists() bool {
	return rc._exists
}

// Deleted returns true when the RuntimeConfig has been marked for deletion from
// the database.
func (rc *RuntimeConfig) Deleted() bool {
	return rc._deleted
}

// Insert inserts the RuntimeConfig to the database.
func (rc *RuntimeConfig) Insert(ctx context.Context, db DB) error {
	switch {
	case rc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case rc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO runtime_configs (` +
		`user_id, platform, runtime, config, last_seen` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)`
	// run
	logf(sqlstr, rc.UserID, rc.Platform, rc.Runtime, rc.Config, rc.LastSeen)
	if _, err := db.ExecContext(ctx, sqlstr, rc.UserID, rc.Platform, rc.Runtime, rc.Config, rc.LastSeen); err != nil {
		return logerror(err)
	}
	// set exists
	rc._exists = true
	return nil
}

// Update updates a RuntimeConfig in the database.
func (rc *RuntimeConfig) Update(ctx context.Context, db DB) error {
	switch {
	case !rc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case rc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE runtime_configs SET ` +
		`platform = $1, runtime = $2, config = $3, last_seen = $4 ` +
		`WHERE user_id = $5`
	// run
	logf(sqlstr, rc.Platform, rc.Runtime, rc.Config, rc.LastSeen, rc.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, rc.Platform, rc.Runtime, rc.Config, rc.LastSeen, rc.UserID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the RuntimeConfig to the database.
func (rc *RuntimeConfig) Save(ctx context.Context, db DB) error {
	if rc.Exists() {
		return rc.Update(ctx, db)
	}
	return rc.Insert(ctx, db)
}

// Upsert performs an upsert for RuntimeConfig.
func (rc *RuntimeConfig) Upsert(ctx context.Context, db DB) error {
	switch {
	case rc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO runtime_configs (` +
		`user_id, platform, runtime, config, last_seen` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (user_id) DO ` +
		`UPDATE SET ` +
		`platform = EXCLUDED.platform, runtime = EXCLUDED.runtime, config = EXCLUDED.config, last_seen = EXCLUDED.last_seen `
	// run
	logf(sqlstr, rc.UserID, rc.Platform, rc.Runtime, rc.Config, rc.LastSeen)
	if _, err := db.ExecContext(ctx, sqlstr, rc.UserID, rc.Platform, rc.Runtime, rc.Config, rc.LastSeen); err != nil {
		return logerror(err)
	}
	// set exists
	rc._exists = true
	return nil
}

// Delete deletes the RuntimeConfig from the database.
func (rc *RuntimeConfig) Delete(ctx context.Context, db DB) error {
	switch {
	case !rc._exists: // doesn't exist
		return nil
	case rc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM runtime_configs ` +
		`WHERE user_id = $1`
	// run
	logf(sqlstr, rc.UserID)
	if _, err := db.ExecContext(ctx, sqlstr, rc.UserID); err != nil {
		return logerror(err)
	}
	// set deleted
	rc._deleted = true
	return nil
}

// RuntimeConfigByUserID retrieves a row from 'runtime_configs' as a RuntimeConfig.
//
// Generated from index 'sqlite_autoindex_runtime_configs_1'.
func RuntimeConfigByUserID(ctx context.Context, db DB, userID string) (*RuntimeConfig, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, platform, runtime, config, last_seen ` +
		`FROM runtime_configs ` +
		`WHERE user_id = $1`
	// run
	logf(sqlstr, userID)
	rc := RuntimeConfig{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID).Scan(&rc.UserID, &rc.Platform, &rc.Runtime, &rc.Config, &rc.LastSeen); err != nil {
		return nil, logerror(err)
	}
	return &rc, nil
}
