package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Vertex represents a row from 'vertexes'.
type Vertex struct {
	RunID     string         `json:"run_id"`     // run_id
	Digest    string         `json:"digest"`     // digest
	Name      string         `json:"name"`       // name
	Cached    int            `json:"cached"`     // cached
	StartTime sql.NullInt64  `json:"start_time"` // start_time
	EndTime   sql.NullInt64  `json:"end_time"`   // end_time
	Error     sql.NullString `json:"error"`      // error
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Vertex exists in the database.
func (v *Vertex) Exists() bool {
	return v._exists
}

// Deleted returns true when the Vertex has been marked for deletion from
// the database.
func (v *Vertex) Deleted() bool {
	return v._deleted
}

// Insert inserts the Vertex to the database.
func (v *Vertex) Insert(ctx context.Context, db DB) error {
	switch {
	case v._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case v._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO vertexes (` +
		`run_id, digest, name, cached, start_time, end_time, error` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	logf(sqlstr, v.RunID, v.Digest, v.Name, v.Cached, v.StartTime, v.EndTime, v.Error)
	if _, err := db.ExecContext(ctx, sqlstr, v.RunID, v.Digest, v.Name, v.Cached, v.StartTime, v.EndTime, v.Error); err != nil {
		return logerror(err)
	}
	// set exists
	v._exists = true
	return nil
}

// Update updates a Vertex in the database.
func (v *Vertex) Update(ctx context.Context, db DB) error {
	switch {
	case !v._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case v._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE vertexes SET ` +
		`name = $1, cached = $2, start_time = $3, end_time = $4, error = $5 ` +
		`WHERE run_id = $6 AND digest = $7`
	// run
	logf(sqlstr, v.Name, v.Cached, v.StartTime, v.EndTime, v.Error, v.RunID, v.Digest)
	if _, err := db.ExecContext(ctx, sqlstr, v.Name, v.Cached, v.StartTime, v.EndTime, v.Error, v.RunID, v.Digest); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Vertex to the database.
func (v *Vertex) Save(ctx context.Context, db DB) error {
	if v.Exists() {
		return v.Update(ctx, db)
	}
	return v.Insert(ctx, db)
}

// Upsert performs an upsert for Vertex.
func (v *Vertex) Upsert(ctx context.Context, db DB) error {
	switch {
	case v._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO vertexes (` +
		`run_id, digest, name, cached, start_time, end_time, error` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (run_id, digest) DO ` +
		`UPDATE SET ` +
		`name = EXCLUDED.name, cached = EXCLUDED.cached, start_time = EXCLUDED.start_time, end_time = EXCLUDED.end_time, error = EXCLUDED.error `
	// run
	logf(sqlstr, v.RunID, v.Digest, v.Name, v.Cached, v.StartTime, v.EndTime, v.Error)
	if _, err := db.ExecContext(ctx, sqlstr, v.RunID, v.Digest, v.Name, v.Cached, v.StartTime, v.EndTime, v.Error); err != nil {
		return logerror(err)
	}
	// set exists
	v._exists = true
	return nil
}

// Delete deletes the Vertex from the database.
func (v *Vertex) Delete(ctx context.Context, db DB) error {
	switch {
	case !v._exists: // doesn't exist
		return nil
	case v._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM vertexes ` +
		`WHERE run_id = $1 AND digest = $2`
	// run
	logf(sqlstr, v.RunID, v.Digest)
	if _, err := db.ExecContext(ctx, sqlstr, v.RunID, v.Digest); err != nil {
		return logerror(err)
	}
	// set deleted
	v._deleted = true
	return nil
}

// VertexesByRunID retrieves a row from 'vertexes' as a Vertex.
//
// Generated from index 'idx_vertexes_run_id'.
func VertexesByRunID(ctx context.Context, db DB, runID string) ([]*Vertex, error) {
	// query
	const sqlstr = `SELECT ` +
		`run_id, digest, name, cached, start_time, end_time, error ` +
		`FROM vertexes ` +
		`WHERE run_id = $1`
	// run
	logf(sqlstr, runID)
	rows, err := db.QueryContext(ctx, sqlstr, runID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Vertex
	for rows.Next() {
		v := Vertex{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&v.RunID, &v.Digest, &v.Name, &v.Cached, &v.StartTime, &v.EndTime, &v.Error); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// VertexByRunIDDigest retrieves a row from 'vertexes' as a Vertex.
//
// Generated from index 'sqlite_autoindex_vertexes_1'.
func VertexByRunIDDigest(ctx context.Context, db DB, runID, digest string) (*Vertex, error) {
	// query
	const sqlstr = `SELECT ` +
		`run_id, digest, name, cached, start_time, end_time, error ` +
		`FROM vertexes ` +
		`WHERE run_id = $1 AND digest = $2`
	// run
	logf(sqlstr, runID, digest)
	v := Vertex{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, runID, digest).Scan(&v.RunID, &v.Digest, &v.Name, &v.Cached, &v.StartTime, &v.EndTime, &v.Error); err != nil {
		return nil, logerror(err)
	}
	return &v, nil
}

// Run returns the Run associated with the Vertex's (RunID).
//
// Generated from foreign key 'vertexes_run_id_fkey'.
func (v *Vertex) Run(ctx context.Context, db DB) (*Run, error) {
	return RunByID(ctx, db, v.RunID)
}
